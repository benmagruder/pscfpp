
Model (simple bead-spring model):
---------------------------------

   1) Every vertex bead must be "owned" by exactly one of the attached 
      blocks. An end bead is always owned by the single attached block

   2) The bond attaching a vertex to a block is always of the same type 
      as the attached block.

   3) In a linear chain, by default, every block owns its last bead, and 
      the first block also owns its first bead.

   4) In the parameter file for a linear chain, the user sets the number 
      of beads owned by the block.

What new information is required in implementation:

   1) Which polymer model is being used (thread or bead model) ? 
      [Globally accessible enumeration variable]

   2) Which block and/or propagator contains the vertex bead.
      [Define bool member variables in BlockDescriptor and 
       PropagatorTmpl classes]

Implementation stategy:
-----------------------

   1) In class BlockDesriptor, each block has a value for nBead_ (the 
      number of beads that it owns). For a discrete bead model, the
      parameter file should contain values for nBead.  The Rpc::Block 
      and Rpg::Block classes will still also have values for ns_ and ds_. 
      In a thread model, nBead_ = ns_. In a bead model, length = ds*nBead_. 

   2) Internally, each propagator stores ns_ slices, indexed 
      0, ..., ns - 1, as in the current thread model.  Slice 0 is 
      associated with the head vertex and field ns - 1 is associated with 
      the tail vertex.  The number nBead can vary from ns-2 to ns, depending 
      on whether the block owns both, one or none of the two terminating 
      vertex beads.

   3) Propagator slice i associated with bead i contains the field
      weight factor associated with bead i for the head slice (i=0)
      all non-vertex beads (i=1, ..., ns-1). The slice associated with
      the tail vertex bead (i=ns) includes this factor if and only if the 
      propagator owns the tail vertex bead. If propagator does not own 
      the tail vertex, then the slice associated with the tail is treated 
      as a dangling bond, with no weight function arising from the tail 
      vertex bead.
      
   4) A function Block:: stepBead that will be used for steps from
      i-1 to i for i = 1, ..., ns_ - 1 will first apply a bond operator 
      exp(-k^2 b^2 *ds/6) and then a field weight operator exp(W*ds). 

   5) The tail weight for bead ns is obtained by applying a bond operator
      to bead ns - 1, and then applying a field weight if and only if
      the propagator owns the tail vertex bead. 

   6) The head slice for a head vertex that not owned by a propagator 
      is given by the pointwise product of tail fields associated with 
      sources, exactly as in the current code. In this case, this product 
      will always include a weight function for the vertex bead that 
      arises from the tail slice for the source propagator that owns the 
      vertex bead. The head for a propagator that owns the head bead 
      must instead acquire an additional weight factor for the bead.
      This additional weight factor must be applied by the propagator
      that owns the bead, as part of the computation of the slice for
      the head. 

   7) Computation of contributions to monomer concentrations from 
      non-vertex beads must include a factor of the inverse of the
      weight factor associated with that bead, as in Matsen's algorithm. 
      This inverse weight factor should be stored separately, because it
      is applied repeatedly, and because division is 2-3 times more 
      expensive than multiplication.  

   8) The contribution of each vertex bead to overall concentration 
      is only included in summations for the block that owns it. 
      Each such bead has an associated head slice from one propagator 
      and a tail slice from the other associated with the same block
      that both include the weight factor for that vertex bead. The 
      contribution from such a vertex bead must thus include a factor 
      of the inverse of the bead field weight, exactly as for non-vertex 
      beads. 

Proposed Implementation:
------------------------

1) Define an namespace Pscf::PolymerModel that contains an unscoped
   (C-style) enumeration and several functions to set and get a value:

namespace Pscf{
namespace PolymerModel{

  enum Enum = {Thread, Bead};

  void setModel(PolymerModel::Enum);

  PolymerModel::Enum model();

  bool isThread();
  bool isBead();

  void lock();
  bool isLocked();

}
}

Define extractor and inserter (>> and <<) operators to read and write 
values of this new enum type.

The functions in the namespace set, query and lock values of a 
pseudo-private enumration variable model_ that is defined and initialized 
in an anonymous namespace in PolymerModel.cpp.

The lock() function can be called after the model type is initialized to
make it immutable thereafter.  It should not be used in unit tests, since
it would apply to all subsequent tests.

Rules: 

   - The variable polymerModel_ is initialized to PolymerModel::Thread

   - A non-null value should only be assigned once. Use the lock()
     function to enforce this. 

Note: We could use this pattern later to define enum classes to specify 
whether the interaction is compressible and/or has a nonzero range.

Done

2) Create a member nBead_ in the BlockDescriptor class. 
When PolymerModel::isBead(), have the inserter and extractor operators 
for the BlockDescriptor, read nBead rather than length. For a bead model,
compute ns_ from nBead once it is known which end beads the block owns, 
if any. Allow access to functions that get or set nBead only if 
PolymerModel::isBead().

Done

3) For the BlockDescriptor class, add a private member array Pair<bool> 
isOwner_ , a set function void setVertexOwnership(int i, bool) and a get 
function bool isOwner(int i). Allow access to functions that get or set
isOwner only if PolymerModel::isBead(), since these variables are 
meaningless in a thread model. 

Change the text representation of a block for a branched polymer for 
the bead model so as to read values of isOwner(0) and isOwner(1). 

Note: For linear molecules, values of ownsVertex for each block can be 
set before reading the blocks. 

Done

4) In the PropagatorTmpl class template, define private bool member
variables named ownsHead_ and ownsTail_, and define public accessor 
functions bool ownsHead() and bool ownsTail(). Also define a set
function setVertexOwnwership(ownsHead, ownsTail);

Done

5) In Pscf::PolymerTmpl::readParameters add code to

   - Set vertex ownership for blocks in a linear polymer (before reading blocks)
   - Set head and tail ownership in propagators
   - For each vertex, check that one incoming propagator owns its tail.
   - For each vertex, check that one outgoing propagator owns its head.

Done

6) In Mixture::readParameters, if PolymerModel::isBead(), make reading of 
ds_ optional, and set ds_ = 1.0 by default. 

Done in Rpc

7) Add a private member polymerModel_ to the System class. If 
!PolymerModel::islocked(), optionally read this as the first member 
of the block, before the beginning of the Mixture class. The file 
format would thus be:

  System{
     polymerModel*  PolymerModel::Enum
     Mixture{ ... }
     Interaction{ ... }
      ...
  }
 
Set System::polymerModel_ to PolymerModel::Thread by default.  When the 
value is known (after it is optionally read), set the global variable to 
the same value. 

Done in Rpc

8) In Rpc::Block::allocate and re-allocate functions, for bead model, 
compute ns from nBead. ns is equal to nBead when both vertices are
owned by the block, and  larger than nBead when one or both vertices 
are not owned by the block.

Done in Rpc

9) Modified private data structures in Rpc::Block:

In Rpc::Block class, use expW_ to store exp(-W(r)ds) in the case of the
bead model, but use expW_ to store exp(-W(r)ds/2) in the case of a thread 
model. The value of expKsq_ is the same for the thread and bead models.  
For the bead model, arrays expW2_ and expKSq2_ are left unallocated and 
unused.

Add field expWInv_ that stores exp(+W(r)ds), for use in summations used
to compute monomer concentrations and partition function. This is only
allocated if PolymerModel::isBead().

Modify functions:

     allocate :
       - Conditionally allocate some private member fields
       - Modify definition ns and ds for different models
     setLength :
       - Make PolymerModel::isThread a precondition 
     setupSolver :
       - If blocks around computations of expW_, expW2_, expWInv_
     computeKSq :
       - Compute expKsq2 only if isThread

Done in Rpc

10) Block step functions: 

In Rpc::Block class, change the name of the current step function to 
stepThread.  Add three additional public member functions to give:

   void stepThread(Propagaor const & qin, Propagator & qout) 
   void stepBead(Propagaor const & qin, Propagator & qout) 
   void stepBondBead(Propagaor const & qin, Propagator & qout) 
   void stepFieldBead(Propagator & q)

The function stepFieldBead applies the field weight exp(-W[i]*ds).
Function stepBondBead applies a bond weight by applying an FFT, scaling 
in k space and an inverse FFT.  Note that the stepFieldBead function 
applies the scaling in-place scaling, while other functions have 
distinct input and output field arguments. 

The function stepBead simply calls stepBondBead, then stepFieldBead.

Rationale: Separate functions stepBondBead and stepFieldBead are needed
to correctly treat slices associated with head and tail vertices that
may or may not be owned by the propagator. The function stepBondBead 
is needed by Propagator to compute the weight for a tail bead that is 
not owned. The stepFieldBeadFunction is need as part of the 
computation in computeHeadBead for a head bead that is owned by the 
propagator.

Done in Rpc

11) Propagator computeHead functions for both models:

In the Propagator class change the name of the current computeHead
function to computeHeadThread() and define an additional function
computeHeadBead(). The computeHeadBead function call computeHeadThread 
internally, then apply Block::stepFieldBead iff the propagator owns 
the head vertex bead.

Done in Rpc

12) Block averageProduct functions:

In the Rpc::Block class, add two functions that can be used by 
Propagator::computeQ to compute the partition function from the 
product of complementary incoming and outgoing slices at a vertex.

   double averageProduct(RField<D> const& qh, RField<D> const& qt)
   double averageProductBead(RField<D> const& qh, RField<D> const& qt)

Function averageProduct returns the spatial average of qh[i]*qt[i], 
and can be used with the thread model or for the bead model for a
bead that is not owned by the propagator. 

Function averageProductBead computes the spatial average of 
qh[i]*qt[i]/exp(W[i]*ds), and is designed for a vertex bead that 
is owned by the propagator.

In Propagator::computeQ, call the appropriate choice of one of these 
two functions.

Done in Rpc

13) Propagator::solve function:

In Propagator::solve, use an if-else statement to separate 
MDE solver code for the thread model from corresponding code for
the bead model . Code for the thread model invokes computeHeadThread 
and stepThread. Code for the bead model uses computeHeadBead and 
stepBead, while using stepBondBead for the tail bead if this 
propagator does does not own the tail vertex bead.

Done in Rpc

14) Move responsibility for block concentrations to subclasses:

In PolymerTmpl, remove code that computes all block concentrations by 
calling Block::computeConcentratiosn for all blocks from the 
PolymerTmpl::solve() function. Leave this computation as the 
responsibility of the Polymer::compute function in each 
implementation-level subclass (r1d, rpc, and rpg). Thus add 
corresponding code to the end of the Polymer::compute function in 
each implementation of Polymer. 

The code added to the end of R1d::Polymer::compute and 
Rpg::Polymer::compute is almost identical to the code removed from 
PolymerTmpl::solve. 

The code in Rpc::Polymer::compute allows for thread and bead models, as 
will corresponding code in Rpg::Polymer::compute when converted later.

Rationale: Different implementations of this calculation are needed 
for codes that only support a thread model and those that support 
both thread and bead models. The definitions of prefactors that are 
computed by the Polymer class are different for these models, for
reasons that are discussed below.  Delegating responsibility for 
computation of block concentrations to a Polymer subclass makes it 
easier to distinguish these cases in implementations that support 
both models. 

Done in Rpc

14) Computation of block concentration in Block class:

In Block class, define two public functions:

    computeConcentrationThread(double prefactor)
    computeConcentrationBead(double prefactor)

One or the other of these functions is called with an appropriate value 
for the prefactor within the Rpc::Polymer::compute class.

In the thread model, the prefactor must be phi/(q L), where L is the sum 
of the lengths of all the blocks, while computeConcentrationThread 
computes an integral over s (including factors of ds in contributions
to the sum, and using Simpson's rule) and multiplies it by a prefactor

In the bead model, the prefactor must be phi/(q N), where N is the total 
number of beads owned by all blocks, computeConcentrationBead computes 
a sum over all beads that are owned by the block and multiplies it by 
this prefactor.  The summation in computeConcentrationBead is a simple 
sum over all beads that are owned by the block, including a factor of
exp(W[i]*ds) for each bead to correct for overcounting of bead weight 
factors.

Rationale: We use different conventions for the prefactor for the thread 
and the bead model because the Polymer class that computes the prefactor 
knows the length of each block in the thread model and the number nBead
of beads in each block in the bead model, but does not know a value for 
ds that it could use to convert the number of beads to an equivalent 
length.

Done in Rpc

15) Figure out how to modify the computeStress function. We need to
work through this analysis for the discrete model before making
corresponding changes in the code.  We can test code that uses 
rigid unit cells in the meantime.

TODO
