/*! \page psfts_algorithm_page  Simulation Algorithms

\ref psfts_psa_page    (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_param_page  (Next) &nbsp; &nbsp; &nbsp; &nbsp;
<BR>

This page provides a brief introduction to several types of algorithm that 
are needed to perform and analyze PS-FTS calculations , but that are not 
needed for SCFT calculations. This introduction is a prerequisite to a 
discussion on the \ref psfts_param_page "following page" of parts of the 
parameter file in which the user specifies choices for various simulation 
algorithms and associated parameters.

The pscf_pc and pscf_pg programs allow PS-FTS simulations to be performed 
using either Brownian dynamics (BD) or Monte Carlo (MC) algorithms to 
stochastically sample a fluctuating field or fields.  BD and MC sampling 
algorithms for PS-FTS have a similar structure.  A single BD step or MC 
move generally requires generation of a random change in one or more 
exchange fields, followed by use of an iterative algorithm to identify
a new partial-saddle point configuration. Throughout the PSCF 
documentation and source code, iterative algorithms that are used to 
identify partial saddle-point configurations, and thus satisfy the 
menan-field incompressibility constraint, are referred to as "compressor" 
algorithms.

For example, consider a PS-FTS simulation of a standard AB system 
with two monomer types. Such a system has a real exchange field 
\f$ W_{-}({\bf r}) = \omega_{-}({\bf r}) \f$ that undergoes random 
fluctuations and a real pressure-like field 
\f$ W_{+}({\bf r}) = i \omega_{+}({\bf r})\f$ that must be chosen to 
satisfy the partial saddle-point condition. At the beginning of either a 
BD step or MC move for such as system, a small random change is added to 
the exchange field \f$ W_{-} \f$.  Next, an iterative compressor algorithm 
is used to adjust the presssure-like field \f$ W_{+}({\bf r}) \f$ so as 
to satisfy the partial saddle-point condition, thus imposing 
incompressibility at a mean-field level.  Finally, for an MC simulation, 
a decision is made about whether to accept or reject the resulting MC 
move, based on the value of the Hamiltonian in the new partial 
saddle-point configuration.

PSCF also provides tools for data analysis. Users may use the parameter 
file to choose from among a set classes that can periodically compute 
specific physical quantitites, output data to a file, and/or perform 
statistical analyses during a simulation to compute time averages and 
other statistical properties.  C++ classes that implement such operations 
are referred to generically as analyzers or analyzer classes. Each analyzer 
class performs a specified analysis and/or file IO operation at some regular 
interval during a simulation (e.g., every 10 or 100 simulation steps).  

The parameter file for a typical PS-FTS calculation will thus normally
contain a choice of algorithms for the following three purposes:

   - **Sampling** :  A BD step algorithm or a set of MC step algorithms
     that is used to update the fluctuating field components.

   - **Compressor** :  A compressor algorithm that is used to adjust
     the pressure-like field \f$ W_{+} \f$ so as to always satisfy the 
     partial saddle-point condition.

   - **Analyzers** :  File IO and/or data analysis operations that 
     are performed at regular intervals during a simulation.

In addition to these basic building blocks, users may also enable two
other types of optional elements:

   - **Ramp** : A Ramp is a optional feature that allows a user to
     perform a simulation in which one or more model parameters are
     varied continuously over the course of a simulation.

   - **Perturbation** : A Perturbation is an optional feature that
     allows the user to modify the form of the field theoretic
     Hamiltonian by adding a perturbation to the standard form

All of these features are discussed separately below.

In the source code of PSCF, different algorithms of the same type are 
generally implemented by C++ classes that are subclasses of a common 
base class. The generic names that we use in this documentation to 
describe different types of algorithm usuall correspond to the names 
of the corresponding base classes. For example, each Brownian dynamics 
step algorithms is implemented by a subclasses of a base class named 
BdStep, while Monte Carlo moves are implemented by subclasses of base 
class named McMove. Classes that perform file IO and data analysis
operations are subclasses of a class named Analyzer. Classes that
perform parameter ramps or define perturbations are subclasses of 
base classes named Ramp and Perturbation.

The PSCF parameter file format uses selectable parameter file blocks
to allow a user to choose one from a set of different algorithms of 
the same type (as is appropriate for BdStep an Compressor algorithms) 
or to user to choose one or algorithms from among a list of available 
algorithms of the same type (as is appropriate for McMove and Analyzer 
algorithms).

\section psfts_algorithm_BD_sec Brownian Dynamics (BD) Step Algorithms

A Brownian dynamics (BD) algorithm for a particle based simulation is
usually based on discretization of a stochastic differential equation
that generates diffusive dynamics. In the context of a field theoretic
simulation, however, there is no natural way to define dynamics or units
of time, since the BD algorithm is simply being used as a way to sample
an equilibrium distribution. The description of BD step algorithms 
used to define parameters in PSCF based on units in which the fictitious 
"time" is thus measured in units of BD steps, while energy is measured 
in thermal units, in which \f$ kT = 1 \f$.  The magnitude of changes in 
the exchange field(s) per time step is controlled by a parameter that 
is denoted by the label "mobility" in the parameter file, and denoted 
by the symbol \f$ \gamma \f$ in these notes.

As an example, consider the explicit Euler BD step algorithm for a 
standard AB system. This algorithm yields a change 
\f$ \Delta W_{-}({\bf r}) \f$ per time step in the exchange field 
\f$ W_{-}({\bf r}) \f$ at grid point \f$ {\bf r} \f$ that is given by
\f[
  \Delta W_{-}({\bf r}) =
  - \gamma \frac{\delta H}{\delta W_{-}({\bf r})}
  + g({\bf r})
\f]
where \f$ \gamma \f$ is the BD mobility parameter, \f$ g({\bf r}) \f$ is 
a random field displacement, and
\f[
  \frac{\delta H}{\delta W_{-}({\bf r})}
  = \frac{1}{v} \left [
    \frac{2 W_{-}({\bf r})}{\chi_{b}}
    - \Phi_{-}({\bf r}) \right ]
    \quad.
\f]
The random displacement \f$ g({\bf r}) \f$ is chosen independently at 
each node of the computational mesh and each BD step from a Gaussian 
distribution with a vanishing mean value, \f$ \overline{g({\bf r})} = 0\f$, 
and with a variance
\f[
  \overline{g^{2}({\bf r})} = \gamma \Delta V \quad.
\f]
Here, \f$ \Delta V \f$ is the volume per node (or grid point) of the 
computational mesh, given by \f$ \Delta V = V/G \f$, where \f$ V \f$ is 
the total system volume and \f$ G \f$ is the total number of nodes in the 
mesh.  Other authors have sometimes referred to what we call a "mobility" 
as a time step, sometimes indicated by a symbol such \f$ \Delta t \f$ or
\f$ \delta t \f$.

The mobility parameter has an analogous meaning in more sophisticated
BD step algorithms. It always appears as a prefactor of the "force"
(or functional derivative) \f$ \delta H/\delta W_{-}({\bf r}) \f$ in 
expressions for changes in \f$ W_{-}({\bf r}) \f$ over a single time
step.

PSCF currently allows users to choose from among three BD step 
algorithms, which are labelled below by the names of the C++ classes
that implement them:
<ul>
  <li> \ref rpc_LMBdStep_page "LMBdStep" : A "Leimkuhler-Matthews" (LM) 
  BD step algorithm </li>
  <li> \ref rpc_PredCorrBdStep_page "PredCorrBdStep": A predictor 
  corrector algorithm,
  </li>
  <li> 
  \ref rpc_ExplicitBdStep_page "ExplicitBdStep" : An explicit
  Euler algorithm like that described above,  </li>
</ul>
More details about each of these algorithms can be obtained by clicking
on the associated link.

We recommend the Leimkuhler-Matthews (LM) algorithm for general use 
in all BD simulations.  The LM step algorithm is found to provide much
more accurate results than the competing predictor-corrector algorithm, 
allowing the use of larger time steps.  The explicit Euler algorithm is 
signficantly less accurate than the other two alternatives.

\section psfts_algorithm_MC Monte Carlo (MC) Move Algorithms

The PSCF implementation of MC sampling allows the user to specify a set 
of Monte Carlo move types to be used during an MC simulation. When more
than one type of move is specified, one of the move types is chosen at 
random at the beginning of each step, using probabilities that are
specified by the user.  The algorithm for each attempted step of a MC 
simulation is thus as follows:

   - Choose a type of MC move at random from among a set of choices
     specified by the user.

   - Use the chosen MC move to generate a random change in \f$ W_{-} \f$.

   - Use the chosen compressor algorithm to adjust the real pressure-like 
     field \f$ W_{+}({\bf r}) \f$ so as to satisfy the partial 
     saddle-point condition.

   - Evaluate the Hamiltonian in the new partial saddle point state.

   - Use a Metropolis criterion that is designed to satisfy detailed 
     balance to decide whether to accept or reject the move.

   - If the move is rejected, restore the system to the field 
     configuration that had existed before the beginning of the 
     attempted move.

The block of the parameter file for an MC simulation that contains 
information about MC moves, which is labelled "McMoveManager", contains 
one or more subblocks that are associated with different types of move.  
The parameter file block associated with each such MC move type always
contains a "probability" parameter that specifies the probability of 
that type of move being chosen at the start of each step.

PSCF currently only provides the following two MC step algorithms: 
<ul>
  <li> \ref rpc_ForceBiasMove_page "ForceBiasMove": A "smart MC" or
  "force bias" MC move that uses an explicit Euler BD step to 
  generate a proposed MC move. </li>
  <li> \ref rpc_RealMove_page "RealMcMove" : A simple MC move that 
  generates spatially uncorrelated random changes of 
  \f$ W_{-} \f$ at different grid points </li> 
</ul>
The ForceBiasMove algorithm generally leads to much more efficient 
sampling than the simpler real move, and is recommended as the 
workhorse method for MC simulations.

Acceptance rates for MC moves generally decrease rapidly with 
increasing system size. This effect is particularly severe with the 
simple real-space MC move, but also occurs for the force bias move.
Because BD simulation does not suffer from a similar problem, this 
phenomena causes MC to always become less efficient than BD for 
sufficiently large systems. We thus generally recommend the use of BD 
rather than MC simulation for 3D systems with roughly \f$ 10^{4} \f$ 
or more grid points. 

One virtue of MC simulations over BD simulations is that, because MC 
algorithms are designed to satisfy a detailed balance condition, they 
do not exhibit any systematic sampling error. An infinitely long MC 
simulation should, in principle, yield exact results for any average 
value obtained from a particular model on a specified computational
mesh. The only sampling errors in MC simulations are true statistical 
errors arising from the finite length of a simulation, which can be 
estimated by standard methods, and errors arising from round off of 
floating point numbers, which are usually negligible.  BD simulations
instead exhibit an systematic error due to discretization of the time 
coordinate in the Langevin equation, an error that increases with 
increases in the mobility parameter. Results of MC simulations of 
small systems can thus be useful for comparison when evaluating 
correctness of new MC and BD algorithms, and when evaluating systematic 
errors in BD algorithms.

\section psfts_algorithm_compressor_sec Compressor Algorithms

The PSCF paramater file format allows the user to choose from among
several "compressor" algorithms. As discussed above, a compressor is 
an iterative algorithms that adjust the \f$ W_{+} \f$ field so as to 
satisfy a partial saddle-point condition. This algorithm must applied 
at last once per BD or MC stochastic step after each change in 
\f$ W_{-} \f$. Users may choose a compressor algorithm independently 
of their choice for a BD step or MC move algorithms: Any compressor 
algorithm may be used in the context of any BD or MC step algorithm. 

Solution of the saddle-point condition normally requires multiple
iterations of \f$ W_{+} \f$. Each iteration normally involves a 
proposed adjustment of \f$ W_{+} \f$ followed by solution of the 
modified diffusion equation (MDE) in the resulting state, which 
is necessary to evaluate the remaining error. Because repeated
solution of the MDE is the most expensive operation in a FTS, and
the compressor algorithm requires multiple solutions of the MDE 
for each BD or MC step, almost all of the computational time of
PS-FTS calculation is spent within the compressor algorithm. 

The available compressor algorithms are listed below. Users may 
click on the link associated with each algorithm label to access 
more a detailed description of each the algorithm, and of the format 
of the associated parameter file block. 
<ul>
  <li> \ref rpc_LrAmCompressor_page "LrAmCompressor": 
        A linear-response Anderson mixing algorithm </li>
  <li> \ref rpc_LrCompressor_page "LrCompressor": 
        A simple linear-response algorithm </li>
  <li> \ref rpc_AmCompressor_page "AmCompressor":
        An Anderson-mixing algorithm </li>
</ul>
The LrAmCompressor is the default choice, and is recommended for 
general use. 

The AmCompressor algorithm is similar to the Anderson mixing 
algorithm used in most previously published PS-FTS calculations. 
The LrAmCompressor and LrCompressor algorithms use the analytically 
calculated linear response of a hypothetical homogeneous state as 
an approximation to the actual linear response of the monomer 
concentration in an inhomgeneous state to small changes in the 
pressure-like field (i.e., for the Jacobian of the relevant
system of equations). 

\section psfts_analyzer_BD_sec Analyzer Algorithms

Explain the idea of an analyzer and an analyzer.

All of the analyzer classes that are provided with the current version 
of PSCF (v1.2) are listed below.  More details about the purpose of each 
class and the format of the corresponding parameter file block can be 
obtained by clicking on link in this list:
<ul>
  <li> \subpage rpc_StepLogger_page "StepLogger" </li>
  <li> \subpage rpc_TrajectoryWriter_page "TrajectoryWriter" </li>
  <li> \subpage rpc_ConcentrationWriter_page "ConcentrationWriter" </li>
  <li> \subpage rpc_HamiltonianAnalyzer_page "HamiltonianAnalyzer" </li>
  <li> \subpage rpc_BinaryStructureFactorGrid_page "BinaryStructureFactorGrid" </li>
  <li> \subpage rpc_MaxOrderParameter_page "MaxOrderParameter" </li>
  <li> \subpage rpc_FourthOrderParameter_page "FourthOrderParameter" </li>
  <li> \subpage rpc_ChiDerivative_page "ChiDerivative" </li>
  <li> \subpage rpc_ConcentrationDerivative_page "ConcentrationDerivative" </li>
  <li> \subpage rpc_PerturbationDerivative_page "PerturbationDerivative" </li>
</ul>
The "StepLogger" class simply records the progress of a simulation by 
periodically writing the current number of BD or MC steps to standard 
output.  The TrajectoryWriter class periodically writes w-field 
configurations to a field trajectory file, thus enabling later 
postprocessing of that file.  Information about other analyzer classes 
can be obtained by clicking on the associated links. 

\section psfts_algorithm_ramp_sec Parameter Ramp

A "ramp" is an optional feature for FTS that allows a user to perform 
a simulation in which one or more of the parameters of the model vary 
continuously during the simulation. 

The only ramp algorithm provided by the current version of PSCF is a
implemented by the class LinearRamp. This class allows the users to 
implement a ramp in which one or more of the physical parameters vary 
linearly with the BD or MC step counter.  The interface for a 
LinearRamp is closely analogous to that of the LinearSweep class 
used for SCFT sweep calculations, and is discussed on a
\ref psfts_ramp_page "separate manual page". 

The main uses for parameter ramps are:

  - Inducing a spontaneous phase transformation during a slow parameter 
    ramp to identify the approximate location of an equilibrium phase 
    boundary.

  - Evaluating the integral of some ensemble average with respect to 
    changes in a model parameter in order to implement continuous 
    thermodynamic integration.

Thermodynamic integration is discussed in more detail 
below.

\section psfts_algorithm_perturbation_sec Perturbation

A "perturbation" is an optional feature that allows the user to modify 
the form of the field theoretic Hamiltonian by adding an arbitrary
additional functional of the w-fields to the standard Hamiltonian.

The onlly type of perturbation is currently available is implemented
by the class EinsteinCrystalPerturbation. This class is designed to 
enable the Einstein crystal method of computing absolute free 
energies. The interface for EinsteinCrystalPerturbation is discussed 
in detail on a \ref psfts_perturb_page "separate manual page". 

\section psfts_algorithm_thermoint_sec Thermodynamic Integration


<BR>
\ref psfts_psa_page    (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_page        (Up) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_param_page  (Next) &nbsp; &nbsp; &nbsp; &nbsp;

*/
