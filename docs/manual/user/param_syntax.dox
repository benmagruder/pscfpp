/*! \page user_param_syntax_page 3.3.2 Parameter File Syntax

\ref user_param_example_page    (Up) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_param_mixture_page (Next) 
<BR>

This page gives a slightly more formal description of the syntactical
conventions used in all parameter files. The discussion repeats some 
aspects of the discussion of the example on the previous page, but also 
introduces some ideas.

PSCF parameter files are fixed format files, in which each element can
only appear at a specific location within the file. Some flexibility
can be introduced, however, by allowing some elements to be optional or 
polymorphic, as discussed greater detail below.  The format requires
that the user provide a label at the beginning of each element that 
can be checked against an expected value or an expected set of allowed
values in order to allow the program to check the validity the file 
format while it is being read.

\section user_param_syntax_blocks_section Parameter File Blocks

Every PSCF parameter file consists of a heirarchy of of nested parameter 
blocks that are delimited by opening and closing curly braces.  Each such 
block begins with a capitalized label for the block followed immediately 
by an opening curly bracket on the same line.  Each block ends with a 
closing bracket on a line by itself, as in 
\code
  BlockName{
     ....
  }
\endcode
Note that there may not be any whitespace space between the block 
label (e.g., "BlockName", or "Mixture") and the opening curly bracket.

Each such parameter block may contain a sequence of the following 
types of elements:
<ul>
   <li> 
     Nested Subblocks: Each nested subblock is delimited by a label
     and matched opening and closing curly brackets, as described
     above. 
   </li>
   <li> 
     Individual Parameters:
     Each individual parameter value appears on a single line that 
     contains a parameter label followed by a text representation 
     of the parameter value. Examples in the above parameter file 
     include the integer nMonomer parameter in the Mixture block, 
     and the nBlock and phi parameters within each Polymer subblock
     of the Mixture block. 
   </li>
   <li> 
     1D Arrays of Parameters: Each such array begins with a parameter 
     label that ends with a left square bracket ("[") and ends with line 
     containing a matching right square bracket ("]"). Between these 
     delimiters are lines containing values of array elements, with 
     one value per line, listed in the order of increasing array 
     element index. 
   </li>
   <li> 
     2D Arrays of Parameters:  Each 2D array or matrix of parameters 
     begins with a label and an opening delimiter, and ends with a 
     corresponding closing delimiter.  An example is the chi( .... ) 
     array of the ChiInteraction block, which uses a syntax in which
     the list of elements is delimited by opening and closing 
     parentheses.
   </li>
</ul>
Each block within a parameter file has a fixed file format: The order 
in which elements may appear within each block of a parameter file is 
predefined by the code that reads the block. 

The code that reads a block of a parameter field checks the syntax of
the file format by checking that the label that begins each subblock
and parameter matches an expected value.  If the label does not match
the expected label for a required element, the program will halt 
execution after writing an error message explaining what label it 
expected and what it actually found. When combined with echoing of 
the parameter file (by using "-e" command line option) these error 
messages make it relatively easy for users identify and correct most 
parameter file syntax errors.

The name of each block within a parameter file generally corresponds to 
the name of a class or class template in the underlying C++ code.  The 
data contained within such a block generally contains the information 
required to initialize the internal state of a corresponding instance
of the specified class. The code required to read the parameter file 
block associated for a particular class is almost always defined in a 
member function of that class named "readParameters". Users who are
comfortable with C++ can thus use knowledge of this convention to 
easily find the source code that reads a particular parameter file 
block.

Nesting of blocks within a parameter file reflects parent-child ownership 
relationships among C++ objects: Each subblock generally corresponds to 
an object that the parent object "owns", i.e., either either a member of 
the parent object or a dynamically created object that the parent object 
is responsible for creating and destroying.  The outermost block in the 
above example is a "System" block. This reflects the fact that main 
object in the underlying code for a 1D finite-difference program is an 
instance of the class Pscf::Fd1d::System.

\section user_param_syntax_parameter_section Individual Parameters

Each line that assigns a value to an an individual parameter begins with
a label string that identifies the name of the parameter, followed by one 
or more spaces, and then a text representation of the parameter value.  
The name of each parameter generally corresponds to a slightly modified 
version of the name of a member variable of the relevant parent class,
i.e., a member variable of the class whose name is specfied in the
first line of the innermost enclosing parameter file block. 

Values of individual parameters are read from an input stream using the 
C++ ">>" operator. The value of each parameter that is stored in a 
variable of a primitive C data types (e.g., an integer or floating point 
number) or a string may thus be given using a standard C text 
representation for the relevant data type.

Values of some parameters are stored as instances of non-primitive data 
types, such as classes or enumerations, that are defined within the 
pscf source code.  Values for such variables are also read from file
using the ">>" operator.  In these cases, the text representation of 
the "value" of each such non-primitive variable must defined by 
overloaded iostream extractor (>>) and insertor (<<) operators that 
are defined for that data type. 

For example, in the example, the "type" parameter within each 
Polymer subblock of the Mixture block is stored as an enumeration with 
two possible values, for which the text representations are the strings 
"linear" or "branched". The value of the "type" parameter must thus be
given in the parameter file by a string with one of these two allowed 
values. 

\section user_param_syntax_array_section 1D Arrays of Parameters 

Values of some parameters are stored as elements of a one-dimensional 
array.  Each such array is formatted in a multi-line format in which 
the first row contains a label that contains the name of the array 
followed immediately by an opening square bracket, and the last line 
contains a matching closing square bracket on a line by itself. 
Between these delimiters are values of elements of the array, with 
one element per line. 

Examples of this syntax in the above example are the "monomers" array 
within the Mixture block, and the "blocks" arrays within each Polymer 
subblock of the Mixture block.  The number of expected elements of 
such an array must generally be specified by the value of a parameter 
that appears before the array in the parameter file. For example, the
number of monomer types is specified by parameter nMonomer that 
appears just before the "monomers" array. 

\section user_param_syntax_matrix_section 2D Arrays of Parameters 

Variables that are stored internally in two-dimensional arrays can 
use one of two different multi-line parameter file formats. We will
refer to these in what follows as "element format" and "row format".
In either format, dimensions of 2D arrays must be provided by 
parameters that appear in the parameter file before the array. 

<b> Element Format: </b>
In element format, the value of each nonzero element appears on separate
line. This is the format used in above example for the chi matrix.
The element format for an array starts with a line that contains a 
name label followed immediately by an opening parenthesis, and ends 
with a line containing a closing parenthesis. Between these are lines 
that each contain a row index, column index and value of a single
element. When used for square symmetric matrices, like the chi matrix,
this format requires that one enter either the (i,j) or (j,i) element
but not both. The same value is then assigned to both of these 
equivalent elements when either is encountered in the parameter file. 
In this format, elements that are not assigned values are set to zero 
by default, and distinct nonzero elements can appear in any order.

For example, values for elements of a symmetric matrix of chi 
parameters in a system of 3 monomers (nmonomer = 3) with nonzero 
off-diagonal elements and vanishing diagonal elements might look 
something like this
\code
   chi(
       2   0   30.0
       0   1   10.9
       1   2   34.0
   )
\endcode
In this example, zero values are assigned to all diagonal elements
by default.  Nonzero values could be assigned to diagonal elements
by including them in the parameter file format.

<b> Row Format: </b>
In row format, each line of parameter values contains the values for
all of the elements of one row of a corresponding matrix. The row
format for a 2D array begins with a line that contains a label string
followed immediately by an opening square bracket, and ends with a
line containing a closing square bracket on a line by itself, exactly
as for a 1D array. Between these opening and closing lines are lines 
that each contain one row of the corresponding matrix, with values 
of elements formatted exactly as in the standard representation of 
a matrix as an array of number as used in matrix linear algebra. 

For example, the row format for elements of 2 x 3 matrix named 
"matrix" would use a format something like this:
\code
   matrix[
       -15.3   23.0   1.9
         4.8   -9.7  23.3
   ]
\endcode

\section user_param_syntax_optional_section Optional Elements

Each labelled element in a parameter file (i.e, each block or parameter) 
may be either required or optional. Most elements required. 

The label associated with a required element must appear at the expected 
position in a file format, or the program will halt after writing a
error message to standard output that explains the nature of the error. 

The entry for an optional block or parameter may be either included or 
omitted.  If the label associated with an optional block or parameter is 
not found at the expected location in a parameter file, the program will
continue on and try to instead match the label that was found at that
local with the label that identifies the next expected element.
Optional parameters that are omitted from a parameter file are assigned 
default values. 

When echoing of a parameter file is enabled, by invoking a program with
the -e option, the name of each omitted optional parameters is echoed to
standard output followed by the string "[absent]" to indicate that it
was omitted.

Some parameters or blocks in a parameter file may also be required or 
allowed only if parameters that have been read previously take on 
specific values.  Generally, the pscfpp parameter file format does not 
require or allow entry of parameters that are known to be meaningless 
or irrelevent on the basis of parameter values that appear earlier in 
the parameter file.

\section user_param_syntax_polymorphic_section Polymorphic Blocks

Some blocks in a pscfpp parameter file are "polymorphic".  A polymorphic 
block is one that may contain the initial label and format appropriate 
to any of several possible classes that are subclasses of a particular 
base class, and that that serve analogous purposes. In a polymorphic 
parameter file block, the name of the desired subclass is identified 
by the class name label that appears in the opening line of the block. 
The use of polymorphic blocks allows a user to choose at run time from 
among several possible alternative algorithms or other elements of a 
computation.

For example, the block that represents an iterator in a SCFT calculation 
is usually a polymorphic block. The use of a polymorphic block for 
iterators allows users to specify a choice from among several different 
available iterator algorithms. In the above example, the NRIterator 
block appears at a location at the program expects to find the name 
of one of several possible subclasses of the Fd1d::Iterator base class, 
which implement different iterator algorithms. The appearance of a block 
that begins with the name "NRIterator" tells the program that the user 
has selected a Newton-Raphsom iterator that is implemented by the class 
Fd1d::NRIterator, which is a subclass of Fd1d::Iterator. Different 
Iterator subclasses generally require different parameters, and so 
define different parameter file block formats.
 
<BR>
\ref user_param_example_page  (Up) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_param_mixture_page (Next) 

*/
