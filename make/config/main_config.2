# ======================================================================
# General definitions for all systems (Do not modify)

# Assign value of CXX_FLAGS, depending on whether debugging is enabled
ifdef UTIL_DEBUG
   # Flags for serial programs with debugging
   CXXFLAGS=$(CXXFLAGS_DEBUG)
else
   # Flags for serial programs with no debugging
   CXXFLAGS=$(CXXFLAGS_FAST)
endif

# Initialize INCLUDE path for header files (must include SRC_DIR)
# This initial value is added to in the patterns.mk file in each 
# namespace level subdirectory of the src/ directory.
INCLUDES= -I$(SRC_DIR)

# Variable UTIL_CXX11 must be defined to enable use of features of
# the C++ 2011 language standard. 
UTIL_CXX11=1

# ======================================================================
# Makefile Pattern Rules and Recipes
#
# The makefile variables defined above are used in the makefile rules 
# that control compilation of C++ files, creation of libraries, and
# linking to create executables. The following sections briefly explain
# these rules, to provide a context for the meaning of the variables 
# defined above.
#
#-----------------------------------------------------------------------
# Compiler Pattern Rules:
#
# The top level subdirectories of src/ named util/, pscf/, fd1d/, prdc/,
# pscf/ and pspg/ each contain the source code defined in a particular
# namespace, and are referred to here as name-space level directories.
# Each namespace level directory contains makefile fragments named
# patterns.mk, sources.mk, include.mk, and config.mk. 
# 
# Some namespace level directories of PSCF "depend" on others. 
# A namespace level directory named A is said to depends on directory B 
# if C++ or CUDA source code in A may use names (classes and functions) 
# defined in B. If namespace level directory A depends on directory B,
# then the include.mk file in A will include the config.mk and sources.mk 
# files located in directory B. For example, subdirectory fd1d/ depends on
# the util/ and pscf/ directories, but not on the pscpc/, prdc/ or pspg/
# directories.  You can see what directories a particular namespace level
# directory depends on by inspecting the include.mk file in that directory,
# which contains statements to include config.mk and sources.mk files from
# the namespace-level directories on which that directory depends.
#
# Different makefile pattern rules for compilation of source files are 
# used in different namespace level directories.  The file named
# patterns.mk in each namespace level subdirectory of src/ is a makefile 
# fragment that defines pattern rules used for compiling C++ and (when
# relevant) CUDA source files in that directory.  The pattern rules
# defined in the patterns.mk file in each namespace level directory 
# are expressed in terms of makefile variables that may be defined in
# in the same file, in a namespace level config.mk file or sources.mk
# file for that directory or any other directory that it depends on, or
# in this main config.mk configuration file, which is installed in the 
# root of the $(BLD_DIR) directory, i.e., the bld/ or src/ directory.
#
# The pattern rules for different namespace level subdirectories of src/
# are similar except for differences in the values of two makefile
# variables named INCLUDES and DEFINES that are assigned different values 
# in different namespace level directories. 
#
# Compiling *.cpp C++ files:
#
# The compiler pattern rule for compiling C++ files for each namespace 
# level subdirectory src/ is of the form:
# 
# $(BLD_DIR)/%.o:$(SRC_DIR)/%.cpp
#      $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) $(DEFINES) -c -o $@ $<
#
# This pattern compiles a *.cpp file in a subdirectory of the source
# directory $(SRC_DIR) and creates a *.o object file in a corresponding
# location in a subdirectory of the build directory, $(BLD_DIR). The 
# $(SRC_DIR) and $(BLD_DIR) are the same in the case of in-source 
# compilation. The variables used in this pattern are:
#
# CXX         - C++ compiler executable name 
# CPPFLAGS    - standard options used by the C/C++ preprocessor
# CXXFLAGS    - standard compiler options used during compilation
# INCLUDES    - Directories to search for included header files
# DEFINES     - compiler options that define C preprocessor macros
#
# Values for the variables $(CXX), $(CPPFLAGS) and $(CXXFLAGS) are
# defined above in this main config.mk file.  The same values for these
# variables are used in all namespace level directories.
#
# The variable $(CXXFLAGS) should specify all flags that are used by 
# the compiler, rather than only the preprocessor, and that are used in
# all namespaces. This string normally contains the $(CXX_STD) string 
# as a substring, as well as options that specify the optimization 
# level (e.g., -O3) and any desired compiler warnings (e.g., "-Wall").
#
# The variable $(CPPFLAGS) is empty by default 
#
# The INCLUDES and DEFINES variables are assigned different values 
# in different namespace level subdirectories of src/. Values of
# these variables are assigned in the patterns.mk file in each such
# directory. These values are expressed in terms of values of other 
# makefile variables that may be defined (or not) in the same 
# patterns.mk file, in a namespace level config.mk file located in 
# the same directory or any other namespace level directory that it 
# depends on, or in this main config.mk file. 
# 
# The variable INCLUDES defines the paths used by the C++ compiler
# to search for header files. The default value that is assigned to
# INCLUDES in this main config.mk file sets INCLUDES to the absolute
# path $(SRC_DIR) to the pscfpp/src directory. This path must always
# be included to allow the compiler to find header files that are
# part of the PSCF package.  Pattern rules for some namespace level
# subdirectories add additional paths to directories that contain 
# header files for relevant external libraries (e.g., FFTW, when 
# relevant).
#
# The variable DEFINES is a string that is passed to the compiler
# to define a set of C preprocessor macro definitions.  This variable 
# is not defined in this main configuration file, and is assigned a 
# different value in the patterns.mk file for each namespace level 
# directory. The value of $(DEFINES) defined for each such directory
# contains a string of compiler options that use the compiler "-D" 
# option to define a set of C preprocessor macro definitions that 
# are passed to the compiler. The C/C++ preprocessor macros are used to 
# control conditional compilation of optional features. Each of these 
# preprocessor macros has the same name as a corresponding makefile 
# variable that must be defined to enable the feature. Thus for, 
# example, if the makefile variable UTIL_DEBUG is defined to enable 
# debugging, then the DEFINES string will include a substring 
# "-DUTIL_DEBUG" that instructs the compiler to define corresponding 
# the UTIL_DEBUG C/C++ preprocessor macro. This, in turn, enables 
# conditional compilation of blocks of C++ code that are enclosed 
# between "ifdef UTIL_DEBUG" and "endif" preprocessor statements.
#
# Compiling CUDA (*.cu) source files:
#
# Source files that contain CUDA code are indicated by a file extension
# *.cu. In namespace level directories that contain such files, the
# patterns.mk file also contains an analogous pattern rule for 
# compiling a *.cu file to create a corresponding *.o file. The rule
# for compiling *.cu files is of the form:
# 
# $(BLD_DIR)/%.o:$(SRC_DIR)/%.cu
#      $(NVXX) $(CPPFLAGS) $(NVXXFLAGS) $(INCLUDES) $(DEFINES) -c -o $@ $<
#
# which contains the two new makefile variables
#
# NVX         - CUDA compiler executable name (nvcc)
# NVXXFLAGS   - compiler options used during compilation
#
#-----------------------------------------------------------------------
# Archiver Recipes:
#
# The pscfpp build system creates a static library in each namespace
# level subdirectory of the build directory that contains object code
# created by compiling all the class source files in that directory. 
# The makefile rule to compile this library is defined in the sources.mk 
# file in the same directory. The rule for the Pscf::Fd1d namespace, 
# as an example, is of the form
#
# $(AR) rcs $(fd1d_LIB) $(fd1d_OBJS)
#
# where $(AR) is the name of archiver command used to create a library,
# $(fd1d_LIB) is an absolute path for the resulting library file and 
# $(fd1d_OBJS) is a string that contains absolute paths for all of the
# *.o object files created by compiling source files in the directory
# src/fd1d. Rules for other namespace level directories are analogous.
#
# The fd1d/, pspc/, and pspc/ namespace level directories each contain 
# a *.cpp or *.cu source file that contain the "main" function for an 
# associated executable programs. The libraries in these directories 
# do not contain code created by compiling that main program file.
#
#-----------------------------------------------------------------------
# Linker recipes:
# 
# Executable files are created by linking the compiled main program to
# the required set of static libraries. Reciples for creating executables
# are defined in namespace level makefiles. For example, the recipe
# for creating the fd1d executable is defined in the file fd1d/makefile
# within the relevant build directory (bld/ or src/), and is of the form:
#
#    $(CXX) $(LDFLAGS) -o $(PSCF_FD_EXE) $(PSCF_FD).o $(LIBS)
#
# Here $(PSCF_FD_EXE) is the path to the executable, which is installed 
# in the bin/ directory by default, $(PSCF_FD).o is the path to the 
# object file created by compiling the src/fd1d/pscf_fd.cpp source file,
# which contains the main program. The variable $(LDFLAGS) is empty by
# default.
#
# The variable $(LIBS) is a list of all the static library files that
# must be linked. For each namespace level directory, this contains
# the library in that directory and those in all directories that it
# depends on. For example, in the rule to compile the program fd1d,
# $(LIBS) contains paths to libraries in the uti/, pscf/ and fd1d/
# directories.
#
#=======================================================================
# Automatic dependency generation.
 
# Names of scripts invoked to compute dependencies among header files.
MAKEDEP=$(BIN_DIR)/makeDepCpp
MAKEDEP_CUDA=$(BIN_DIR)/makeDepCuda

# The file $(BIN_DIR)/makeDepCpp and $(BIN_DIR)/makeDepCuda are executable 
# python scripts that are installed in the $(BIN_DIR) specified by this
# config.mk file. These scripts are used during compilation to analyze 
# dependencies among source and header files, and create *.d dependency
# files. Both scripts import a python module named pscfpp.make that is 
# located in the $(ROOT_DIR)/lib/python/pscfpp directory. For the python 
# interpreter to find this, directory $(ROOT_DIR)/lib/python must be in
# the users $PYTHON_PATH environment variable.
